#!/usr/bin/python

import sys;

k = 40634905927881125837687153L #int("0x219cc6aa0ec13d041c4971",16);
totient = 40634905927850661848135028L;
c = 13016925875285007045101206L;

# Assume ethan was right, in that cipher is indeed e, that makes k the mod
# So d is the modular inverse of c over k

def gcd(a,b): # Euclidean Algorithm
	while a:
		a, b = b%a, a;
	return b;

def egcd(a,b): # Extended Euclidean Algorithm
	if a == 0:
		return (b,0,1);
	else:
		g,y,x = egcd(b%a,a);
		return (g, x - (b // a) * y, y);

def modinv(a,m): # Modular Inverse Finder
	g, x, y = egcd(a,m);
	if g != 1:
		raise Exception('modular inverse does not exist');
	else:
		return x % m;

def printableAscii(string):
	charList = list(string);
	for el in string:
		if ord(el) < 32 or ord(el) > 126:
			return False;
	return True;
n = 1522605027922533360535618378132637429718068114961380688657908494580122963258952897654000350692006139
e = 65537
d = 27856072577004096911396713846850363584417408026591016459417310603194644749492416868137791178719126

#c = 202915876039746229935722670340487424839857163073658749653272992778826868242273898753310832920993983342


#p = 44855758538069697551926631915078003399676404099143930649534524703079698887768940444988379114010256588001743873353094466391845015273011594772478638557674761760716597726102880898736621859238396858380726977181774357027793353261968580718693251778086537853742286690197952664236444595948755960699405156130850590142834143054025545655780720987990239407030757258470800761502730473094820652863420309022139764563513781724463162008343146085600572636579510314249118933711941288480734026604635660135606061346212613894607092434553741443587431880941118115625404461510174995529069093023708906844235869898945858799191582231391610715046040440772948983395927590068787959316482854096362452490525611381347788709245099900959340213859725520185673884903300246771522658665485701484165034347276786243317909119256558926857446006481666429126640418762339266178114055674745262341225136972469848147903659652341843152584969798169594807223295352709516378401633517946163754118260318094684444960535879020003649903144514342230920477628697457243501690196366684235109421197942549087527132926382841369257684477154056296209432061707396996602406645799137326770616622569666562365147255045825536604825129022093893586494334230767673617079542620986568809118529044467235119990056534933899604817762318736902058659508017450804719838068515199284202409672149436613501238836032940068492392557866653483737390189446480074895413552452709657444544239711117107885213159613252221366046460882969428480362263481714261965476797021367706422663377427268191154492140297645797330547211120410034197743326755092006696513526907443785272320671249412960111336863171617781422972

cs = []

f = open('data.txt', 'r').read().split('\n')[:-1]

for i in f:
    cs.append(int(i))

string = ""

for c in cs:
    m = pow(c, d, n)
    hexM = hex(m)
    if len(str(hexM[2:-1])) % 2 == 0:
        string += hexM[2:-1].decode('hex');
        print hexM[2:-1].decode('hex')
    else:
        string += (hexM[2:-1] + '0').decode('hex');
        print (hexM[2:-1] + '0').decode('hex');

actual_answer = ""

for char in string:
    if not (ord(char) < 32 or ord(char) > 126):
        actual_answer += char


print actual_answer

#d = modinv(c,totient); # Doesn't make sense b/c c is not coprime to totient
#d = modinv(c/2,totient); # Makes 0 sense

#f = open("RSASolve.txt","a");
#
#for e in range(0,int(sys.argv[1])):
#	if gcd(e,totient) == 1:
#		d = modinv(e,totient);
#		m = pow(c,d,k);
#		hexM = hex(m);
#		#print "e: %d" %(e);
#		#print "d: %d" %(d);
#		#print "Hex: %s" %(hex(d));
#		if len(str(hexM)[2:-1]) % 2 == 0:
#			#f.write("\n" + str(e) + ": " + str(hexM)[2:-1].decode("hex"));
#			if printableAscii(str(hexM)[2:-1].decode("hex")):
#				print str(hexM)[2:-1].decode('hex');
#		#print "Result: %s" %(hex(d)[2:].decode("hex"));
#
#print "we done here"
#
#
##Str = hexD[2:]
##print Str.decode("hex");
